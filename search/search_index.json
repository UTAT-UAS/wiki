{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to the UAS Software Wiki!","text":"<p>Home to:</p> <ul> <li>Repository documentation</li> <li>Software guides</li> <li>Tutorials</li> <li>Knowledge bases</li> </ul> <p>See our GitHub organization: https://github.com/UTAT-UAS</p>"},{"location":"Multirotor/about/","title":"About","text":"<p>New here? See the tutorials to get started</p> <p>UAS Software documentation for multirotor specific repositories.</p>"},{"location":"Multirotor/about/#overview","title":"Overview","text":"<p>Currently the following projects exist:</p> <ul> <li>Computer Vision</li> <li>Flight Stack</li> <li>Flight Visualizer</li> <li>Hardware Manager</li> </ul> <p>At a high level they can be viewed like this:</p> <pre><code>graph LR\n  Z{{Flight Computer}} &lt;==&gt;|uXRCE-DDS| A\n  A{{Companion Computer}} &lt;==&gt;|ROS2| B{{ROS2 Network}};\n  B &lt;==&gt;|ROS2| C[Flight Stack];\n  B &lt;==&gt;|ROS2| D[Flight Visualizer];\n  B &lt;==&gt;|ROS2| E[Computer Vision];\n  B &lt;==&gt;|ROS2| F[Hardware Manager];\n  F &lt;==&gt;|Linux| G{{Peripherals}};\n  C .-&gt;|API| F;\n  D .-&gt;|API| F;\n  E .-&gt;|API| F;</code></pre>"},{"location":"Multirotor/Computer_Vision/","title":"Computer Vision","text":"<p>wip</p>"},{"location":"Multirotor/Flight_Stack/","title":"Flight Stack","text":"<p>wip</p>"},{"location":"Multirotor/Flight_Stack/flight_core/","title":"Flight Core","text":"<p>wip</p>"},{"location":"Multirotor/Flight_Stack/flight_planner/","title":"Flight Planner","text":"<p>wip</p>"},{"location":"Multirotor/Flight_Visualizer/","title":"Flight Visualizer","text":"<p>wip</p>"},{"location":"Multirotor/Hardware_Manager/","title":"Hardware Manager","text":""},{"location":"Multirotor/Hardware_Manager/#flashing-jetson-nano-orin","title":"Flashing Jetson Nano Orin","text":"<p>It is easiest to do this on native Ubuntu.</p> <p>Follow this guide to install the Nvidia sdkmanager</p> <p>You will have to create and login with a Nvidia developers account, then follow the instructions in the installer. Make sure to install with CUDA.</p> <p>It appears that when in recovery mode the carrier board does not spin the fan on the Jetson module, use an external fan to cool the module otherwise it may power off due to overheating. The fan will spin once the OS installation has reached a certain point.</p>"},{"location":"Multirotor/Hardware_Manager/#setting-up-jetson","title":"Setting Up Jetson","text":"<ul> <li>Disable desktop and misc services https://www.jetson-ai-lab.com/tips_ram-optimization.html</li> <li>Change fan curve to cool</li> <li>Update system</li> <li>Install/setup ROS2</li> <li>Install uXRCE-DDS</li> <li>Install/setup Tailscale</li> </ul>"},{"location":"Multirotor/Hardware_Manager/#installing-pytorch","title":"Installing PyTorch","text":"<p>This is probably how you do it (Jetpack 6.2, CUDA 12.6)</p> <pre><code>sudo apt-get update\nsudo apt-get install -y python3-pip libopenblas-dev libcusparselt-dev\n</code></pre> <p>Install:</p> <ul> <li>https://developer.nvidia.com/cusparselt-downloads?target_os=Linux&amp;target_arch=aarch64-jetson&amp;Compilation=Native&amp;Distribution=Ubuntu&amp;target_version=22.04&amp;target_type=deb_network _ https://developer.nvidia.com/cudss-downloads?target_os=Linux&amp;target_arch=aarch64-jetson&amp;Compilation=Native&amp;Distribution=Ubuntu&amp;target_version=22.04&amp;target_type=deb_network</li> </ul> <pre><code>sudo apt-get install -y cuda-cupti-12-6\n</code></pre> <pre><code>python3 -m pip install torch==2.8.0 torchvision==0.23.0 --index-url=https://pypi.jetson-ai-lab.io/jp6/cu126\n</code></pre>"},{"location":"Multirotor/Hardware_Manager/#other-links","title":"Other Links","text":"<p>https://docs.nvidia.com/deeplearning/frameworks/install-pytorch-jetson-platform/index.html https://ninjalabo.ai/blogs/jetson_pytorch.html</p> <p>Can also install cusparselt like this?</p> <p>https://github.com/pytorch/pytorch/blob/main/.ci/docker/common/install_cusparselt.sh</p>"},{"location":"Multirotor/Hardware_Manager/#serial-ssh","title":"Serial SSH","text":"<pre><code>ssh &lt;user&gt;@192.168.55.1\n</code></pre>"},{"location":"Multirotor/Hardware_Manager/#flashing-from-docker-container","title":"Flashing from Docker Container","text":"<p>Potentially useful tips:</p> <ul> <li>This must be done on a Linux machine (WSL2 might work according to the internet).</li> <li>Add \"nfs\" to your supported file systems and kernel modules</li> <li>Install udev in the container</li> <li><code>QEMU</code> with <code>aarch64-linux</code> support must be installed on the host machine. On <code>NixOS</code> install <code>QEMU</code> system wide and add <code>\"aarch64-linux\"</code> to <code>boot.binfmt.emulatedSystems</code>. https://wiki.nixos.org/wiki/QEMU</li> <li>Run <code>sudo update-binfmts --enable qemu-aarch64</code> in the container before launching the <code>sdkmanager</code>, you might have to install <code>qemu-user-static</code> before you run this (or after sdkmanger fails?).</li> </ul> <p>Useful forum links:</p> <ul> <li>https://www.jetson-ai-lab.com/initial_setup_jon_sdkm.html</li> <li>https://forums.developer.nvidia.com/t/orin-nano-installation-fails-chroot-failed-to-run-command-dpkg-exec-format-error/263215/6</li> </ul>"},{"location":"Multirotor/Tutorials/","title":"Tutorials","text":"<p>First Steps - Tutorials that take you from the very beginning of setup to writing actual code.</p>"},{"location":"Multirotor/Tutorials/First_Steps/","title":"First Steps","text":""},{"location":"Multirotor/Tutorials/First_Steps/#introduction","title":"Introduction","text":"<p>These tutorials cover the installation of a developer environment for working with ROS2+PX4, basic navigation within the environment, and conclude with tutorial recommendations and an onboarding project.</p> <p>Knowledge assumptions:</p> <ul> <li>These tutorials assume some knowledge of programming (C++ or Python)</li> <li>These tutorials assume some knowledge of git</li> <li>These tutorials assume limited knowledge of the terminal</li> <li>These tutorials assume no knowledge of Linux</li> <li>These tutorials assume no knowledge of dev-containers</li> <li>These tutorials assume no knowledge of ROS2, PX4, etc.</li> </ul>"},{"location":"Multirotor/Tutorials/First_Steps/#index","title":"Index","text":"<ol> <li>Developer Environment</li> <li>Interacting with the Environment</li> <li>Recommended Tutorials</li> </ol>"},{"location":"Multirotor/Tutorials/First_Steps/1._Developer_Environment/","title":"Developer Environment","text":"<p>The infamous problem of \"it works on my machine\" can be (mostly) solved by using dev containers. A dev container is a consistent environment for building and running software. Most are run on Docker, a light weight virtualisation engine which allows us to run a Linux system on top of our own with minimal overhead. This allows us to run and build software meant for specific environments on our own machine without needing to match the exact version of dependencies and change our hosts configuration.</p>"},{"location":"Multirotor/Tutorials/First_Steps/1._Developer_Environment/#os-support-and-linux","title":"OS Support and Linux","text":"<p>Linux is a open source operating system and is favoured by developers (and many home users) for the control it gives the user over their computer. This is one of the many reasons that makes Linux favoured in robotics applications. Specific to us is the distribution of Linux known as <code>Ubuntu 22.04</code>, which is the only version of Linux that <code>ROS2 Humble</code> officially supports. It is also the only distribution that <code>Gazebo</code> officially supports, and the PX4 development toolchain does not support native Windows.</p> <p>A <code>distribution</code> of Linux is an operating system that uses the Linux kernel, different distribution will package software differently, release updates differently, use different init systems, come with different default software, and much more.</p> <p>This guide recommends the native installation of <code>Ubuntu 22.04</code> for development as this is a relatively user friendly distribution and will help you get familiar with the developer environment in which we work.</p> <p>These tutorials will assume you are using Linux, WSL and macOS notes will be provided when applicable. (PRs welcome)</p> <p>Note that once you get the container setup, your host OS will be largely irrelevant.</p> WSL2 <p>Docker on Windows via WSL2 can be used, however Gazebo (the simulator) seems to have problems with using the GPU. If you'd like to try here are some resources that may help:  https://learn.microsoft.com/en-us/windows/ai/directml/gpu-cuda-in-wsl https://www.reddit.com/r/ROS/comments/1mxwhse/comment/na96uwd/ https://www.reddit.com/r/ROS/comments/1nttl0q/comment/ngx40c8/?context=3  You will also need an Xserver for Windows and set the <code>$DISPLAY</code> env var in your container.  Documentation contributions are welcome.</p> macOS <p>Running the container with x86 emulation should theoretically work, but we have never gotten this working.  You will need an Xserver for Mac.  You may find it easiest to create a VM, an x86 VM is recommended, but you are welcome to try on ARM.  Intel Macs should theoretically work with minimal issues.  Documentation contributions are welcome.</p> ARM <p>Some newer Windows 11 computers (and Apple and Linux) use the ARM instruction set. Unfortunately ARM is not officially supported by PX4 so you will either have to attempt to build the container yourself with some patches (see #Environment), run Docker with some sort of x86 emulation tool, or run Linux in an x86 VM.</p> Other Linux Distros <p>Thanks to containerized development any distro should be compatible with no issues. If you using a different distro please follow your distributions instructions for installing Docker, git, etc.</p> Do I actually need to use this? <p>If you are so inclined it is very much possible to get the required software running without the container. A good place to start would be the Dockerfile in the <code>dev_env</code> repo: https://github.com/UTAT-UAS/dev_env  Although if you are not doing it in some sort of <code>Ubuntu 22.04</code> environment you will struggle.</p>"},{"location":"Multirotor/Tutorials/First_Steps/1._Developer_Environment/#environment-installation","title":"Environment Installation","text":""},{"location":"Multirotor/Tutorials/First_Steps/1._Developer_Environment/#ubuntu-installation","title":"Ubuntu Installation","text":"<p>Skip if you have decided to use WSL2 or macOS.</p> <p>IMPORTANT: Backup any important files on your main drive/partition, if you install Ubuntu correctly there will be no data loss but mistakes happen!</p> <p>See the official docs for installing Ubuntu:</p> <ul> <li>https://canonical-ubuntu-desktop-documentation.readthedocs-hosted.com/en/latest/tutorial/install-ubuntu-desktop/</li> </ul> <p>If you'd like a specific tutorial for installing dual booting Ubuntu, here are some options:</p> <ul> <li>https://linuxconfig.org/how-to-install-ubuntu-20-04-alongside-windows-10-dual-boot</li> <li>https://itsfoss.com/install-ubuntu-1404-dual-boot-mode-windows-8-81-uefi/</li> </ul> <p>Dual boot (as in putting Linux and Windows on the same drive) can be avoided by using another drive, either by adding another to your desktop or using an external SSD on your laptop. The easiest way to install Linux to another SSD is to disconnect all other drives install as normal. Otherwise you will probably have to partition a boot sector manually (depending on the distro's installer).</p> <p>If you'd like to try to keep Bitlocker and secure boot:</p> <ul> <li>https://medium.com/@ethanppl/dual-boot-windows-and-ubuntu-with-secure-boot-and-full-disk-encryption-9c1c3e6e4050</li> </ul>"},{"location":"Multirotor/Tutorials/First_Steps/1._Developer_Environment/#docker","title":"Docker","text":"<p>You will need Docker, it can be installed here (click on Ubuntu): https://docs.docker.com/engine/install/</p> <p>You will want to add yourself to the <code>docker</code> group: https://docs.docker.com/engine/install/linux-postinstall/</p> <p>If you'd like to use Docker Desktop (easiest way to install on Windows and Mac):</p> <p>For WSL2 see here: https://docs.docker.com/desktop/setup/install/windows-install/</p> <p>For Mac see here: https://docs.docker.com/desktop/setup/install/mac-install/</p> <p>For Linux see here: https://docs.docker.com/desktop/setup/install/linux/</p>"},{"location":"Multirotor/Tutorials/First_Steps/1._Developer_Environment/#git","title":"Git","text":"<p>At its core Git allows us to create \"repositories\" that tracks all files you tell it to. You \"save\" the repository by creating commits which contain the differences in text between the previous commit and your changes. This process of storing differences (or \"diffs\") allows the history of a codebase to be tracked and changes made readily apparent.</p> <p>These tutorials will describe how to work with git from the command line. There are GUI (Graphical User Interface) programs to work with git as well, but they will not be covered here.</p> <p>You can install Git here (click on your OS): https://git-scm.com/downloads</p> <p>We will go over Git as we need it, but if you have no experience and would like to do some pre-reading these are some good places to start:</p> <ul> <li>https://learngitbranching.js.org/</li> <li>https://www.w3schools.com/git/</li> </ul>"},{"location":"Multirotor/Tutorials/First_Steps/1._Developer_Environment/#vs-code","title":"VS Code","text":"<p>VS Code is a popular text editor developed by Microsoft, it is highly extendable with many plugins existing that can turn it into a fully featured integrated development environment (IDE).</p> <p>Install VS Code if you haven't already: https://code.visualstudio.com/</p> <p>You will also need the dev containers extension, just search for \"dev containers\" in the extension tab (<code>Ctrl+Shift+X</code>) or see here: https://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.remote-containers</p> <p>If you'd like to learn more about dev containers see here for the full overview: https://code.visualstudio.com/docs/devcontainers/containers</p>"},{"location":"Multirotor/Tutorials/First_Steps/1._Developer_Environment/#github","title":"GitHub","text":"<p>GitHub is a remote Git repository host also owned by Microsoft, it allows us collaborate on a single Git repository.</p> <p>SSH or Secure Shell Protocol is a key based authorization system used to connect to servers and services, and is the recommended way to interact with GitHub.</p> <p>You will need to generate some keys: https://docs.github.com/en/authentication/connecting-to-github-with-ssh/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent</p> <p>Add them to your GitHub account: https://docs.github.com/en/authentication/connecting-to-github-with-ssh/adding-a-new-ssh-key-to-your-github-account</p> <p>These tutorials assume you will configure git and GitHub with SSH.</p>"},{"location":"Multirotor/Tutorials/First_Steps/1._Developer_Environment/#environment","title":"Environment","text":"<p>Open a terminal in the folder/directory where you store your code.</p> <p>Clone the repository with <code>git clone git@github.com:UTAT-UAS/dev_env.git</code></p> <p>https://github.com/UTAT-UAS/dev_env</p> <p>Open the newly created <code>dev_env</code> folder with VS Code, you should be prompted by a pop-up in the bottom right to open this folder in a container, click Yes or equivalent.</p> <p>If not open command palette <code>ctrl+shift+p</code> and search for <code>Dev Containers: Open Folder in Container.</code></p> <p>Dev Containers will now pull the prebuilt base image from <code>ghcr.io</code> and run some setup commands. This should take a few minutes with fast internet.</p> <p>Eventually you should see <code>Done. Press any key to close the terminal.</code></p> Building on ARM <p>PX4 doesn't support this but if you'd like to try, edit the DockerFile to remove the problematic gcc/g++ libs in <code>~/PX4-Autopilot/Tools/setup/ubuntu.sh</code> from the <code>Installing NuttX dependencies</code> section and install the multilib packages before running setup script. You will then need to build the container (see the README.md)  The packages that you might have to install are: <pre><code>gcc-multilib-arm-linux-gnueabi\ngcc-multilib-arm-linux-gnueabihf\ng++-multilib-arm-linux-gnueabi\ng++-multilib-arm-linux-gnueabihf\n</code></pre> Otherwise run with x86 emulation or use a VM.</p>"},{"location":"Multirotor/Tutorials/First_Steps/1._Developer_Environment/#next","title":"Next","text":"<p>Interacting with the Environment</p>"},{"location":"Multirotor/Tutorials/First_Steps/2._Interacting_with_the_Environment/","title":"Interacting with the Environment","text":""},{"location":"Multirotor/Tutorials/First_Steps/2._Interacting_with_the_Environment/#containers","title":"Containers","text":"<p>VS Code is now connected to a <code>container</code>, a container is an instance of an image which was just created. This image is defined from the <code>.devcontainer/Dockerfile</code> which imperatively describes steps to be applied to a base image, in this case <code>osrf/ros:humble-desktop-full</code> which is itself based off of Ubuntu 22.04.</p> <p>VS Code does a lot of heavy lifting and the result is the same UI you might be used to with a few key differences.</p> <p>In the bottom left you will see <code>Dev Container: UAS PX4+ROS2</code> this is similar to the remote development feature of VS Code and lets you know that you are not developing on your host OS.</p> <p>A container is actually mostly isolated from the entire system, this means that it cannot access you local file system unless we tell it to. We mount the <code>dev_env</code> directory to the <code>~/workspace</code> path on the container, this shows up in the file explorer on the side bar. Any changes you make here will be reflected if you open this directory on the host system.</p> <p>Anything you do outside of <code>~/workspace</code> (which you can do via the terminal) will contained to the container and will be lost if you rebuild it.</p> <p>The terminal is also bound to the container and does not interact directly with the host.</p>"},{"location":"Multirotor/Tutorials/First_Steps/2._Interacting_with_the_Environment/#the-terminal","title":"The Terminal","text":"<p>Open the terminal with the default hotkey <code>ctrl+`</code> (or whatever you're used to), this is the window with which we will interact with the system.</p> <p>This terminal by default opens <code>bash</code> a shell that enables us to command the OS. This is similar to cmd or powershell from Windows, macOS by default uses Zsh which is a superset of bash.</p> <p>If you have not cloned any repos you will most likely see:</p> <pre><code>bash: /home/uas/workspace/uas_ws/install/local_setup.bash: No such file or directory\n</code></pre> <p>This is because we do not have a ROS2 colcon workspace setup yet (covered in ROS2 tutorials).</p> <p>You will see <code>uas@ros-dev:~/workspace$</code>, this is the command prompt where you will write commands. <code>uas</code> is the name of the user and is set by the container, <code>ros-dev</code> is the hostname of the system and is set by the container. <code>~/workspace</code> is the current directory you are in, in UNIX like systems <code>~</code> is a shorthand for the \"home\" directory of the user. On this system this expands to <code>/home/uas</code>, this is similar to <code>C:\\Users\\&lt;username&gt;</code> on Windows.</p> <p>Type <code>ls</code> and press enter, you should see a list of files and directories present in the <code>workspace</code> directory. As noted before these are actual files from your host OS that the container has been given access to.</p> <p>Type <code>cd ..</code> to go one directory up and press enter, you should now see <code>uas@ros-dev:~$</code> you are now in <code>~</code> or <code>/home/uas</code>. Type the <code>ls</code> command again, you will see <code>workspace</code> (and maybe some other directories) which is present on your host system! Type <code>cd workspace</code> to go back to where you were before.</p> <p><code>ls</code> can also be extended with optional arguments. Try <code>ls -la</code> you should see that the files have now been printed in a column with additional information on each row, you should also see more files/directories than last time. To learn more about these arguments use the <code>man</code> command (short for manual). Try <code>man ls</code> to see all possible options you can use. Nearly all commands have an associated man page that you can read.</p> <p>This wiki and most external tutorials will provide commands for you to run, but if you'd like to learn what exactly these commands here are some places to start:</p> <ul> <li>https://ubuntu.com/tutorials/command-line-for-beginners#1-overview</li> <li>https://www.freecodecamp.org/news/bash-scripting-tutorial-linux-shell-script-and-command-line-for-beginners</li> </ul> <p>Tip: files in the container can be opened in VS Code with <code>code &lt;filename&gt;</code>. Try it with <code>code /build/PX4-Autopilot/README.md</code>, this opens the PX4 README which was installed to <code>/build</code> by the container! You can also use tools like <code>vim</code> and <code>nano</code> to edit files from the command line, but they will not be covered here.</p>"},{"location":"Multirotor/Tutorials/First_Steps/2._Interacting_with_the_Environment/#package-installation","title":"Package Installation","text":"<p>On Ubuntu and most Linux distributions installation and management of software is done through a <code>package manager</code>. On Ubuntu the <code>apt</code> command can be used to interact with this system.</p> <p>Try typing <code>speedtest-cli</code> you should see <code>bash: speedtest-cli: command not found</code> this is because we need to install it. Try <code>sudo apt install speedtest-cli</code> to install. (type <code>y</code> and enter if prompted)</p> <p>Now if you type <code>speedtest-cli</code> you will get an internet speed test. We can install most programs you can think of this way, if you'd like to view the official list of packages see here: https://packages.ubuntu.com/jammy/</p> sudo? <p>Just as Windows sometimes needs administrator privileges to install software, on most Linux distributions package management must be done with elevated permissions. We call a user with such privileges a \"super user\". The <code>sudo</code> or \"super user do\" command enables a normal user to run a command with elevated permissions. In this container the <code>uas</code> user has been granted passwordless <code>sudo</code>, on most other Linux systems you will find that you will need to enter a password.</p> <p>If you are coming from Windows <code>apt</code> is similar to <code>winget</code>, <code>scoop</code>, or <code>choco</code>. On macOS the equivalent is <code>homebrew</code>.</p>"},{"location":"Multirotor/Tutorials/First_Steps/2._Interacting_with_the_Environment/#the-simulation","title":"The Simulation","text":"<p>Before you start you will have to enable <code>X11</code> pass through, <code>X11</code> is a windowing system that allows programs to draw to the screen and is how the container will create windows on our host computer.</p> <p>For Linux the container is already setup to mount the <code>X11</code> socket and configure <code>$DISPLAY</code>, but you may have to run <code>xhost +local:docker</code> if nothing shows up when you run the simulation. (this command allows non-network local connections to access the X server)</p> <p>For Windows see: https://medium.com/@potatowagon/how-to-use-gui-apps-in-linux-docker-container-from-windows-host-485d3e1c64a3</p> <p>For macOS try: https://gist.github.com/sorny/969fe55d85c9b0035b0109a31cbcb088</p> <p>The <code>dev_env</code> comes preconfigured with a task for running the default simulation. Open command palette <code>ctrl+shift+p</code> and search for <code>Tasks: Run Task</code>, press enter and choose <code>Launch simulator</code>. This will spawn three terminals that will open two windows, the Gazebo sim and QGroundControl. See <code>.vscode/tasks.json</code> if you'd like to see what shell commands get run.</p> <p>If you pan around the scene with your mouse and you are getting more than 10fps then the container is using your GPU correctly. If panning is not smooth and your RTF (real time factor) represented as a percentage in the bottom right is more than 80% than your container is not using your GPU correctly. If you are getting low frames and your RTF is also low than your computer is bad or you have not allocated enough resources to your container.</p> GPU support <p>See the <code>README.md</code> in the <code>dev_env</code> repo to check if someone has already written instructions/tips for your system topology.  If you are on Linux you probably need to install some packages, a good a place to start is to search <code>docker linux &lt;amd/intel/nvidia&gt; &lt;desktop/laptop&gt; gpu</code>  If you are on Windows see the <code>WSL2</code> note back on Developer Environment  Otherwise try searching for <code>docker &lt;operating system&gt; &lt;amd/intel/nvidia&gt; &lt;desktop/laptop&gt; gpu</code></p> <p>If you want to fly the drone you can use the commands on the left of the app like <code>Takeoff</code>, after the drone takes off you can also click on places on the map and tell the drone to fly there. If the simulator does not let you take off please resolve the warnings.</p> <p>You can also control the drone with a virtual joystick (a little difficult to use without a touch screen) to enable go to <code>Application Settings &gt; Fly View &gt; Virtual Joystick</code>.</p> Status warnings <p>The top left section of the status bar is yellow because we have flight warnings, the simulator will probably let you take off without resolving them but if you would to anyways:  Click on the <code>Ready To Fly</code> text in yellow. Under <code>Overall Status</code> you should see <code>No manual control input</code>, you are getting this warning because you have no joystick connected to the simulator. Either enable the virtual joystick or select the <code>COM_RC_IN_MODE</code> parameter in the blue text, change it to <code>Stick input disabled</code> and press save (you should only use this setting in sim).  If you see any other warnings try waiting or restarting the sim, otherwise check the forums.</p> Physical joystick <p>You can use various controllers with QGroundControl as a \"joystick\" to control the drone, most RC controllers should be detected by default. See https://github.com/UTAT-UAS/dev_env?tab=readme-ov-file#joystick for enabling <code>/dev</code> pass through.</p> <p>When ready kill the simulator (close the windows and/or press <code>ctrl+c</code> in the terminal windows).</p>"},{"location":"Multirotor/Tutorials/First_Steps/2._Interacting_with_the_Environment/#next","title":"Next","text":"<p>Recommended Tutorials</p>"},{"location":"Multirotor/Tutorials/First_Steps/3._Recommended_Tutorials/","title":"Recommended Tutorials","text":""},{"location":"Multirotor/Tutorials/First_Steps/3._Recommended_Tutorials/#c-python","title":"C++, Python","text":"<p>Learning an new programming language (or improving your skills) depends on many factors that this tutorial cannot account for.</p> <p>If you have no experience at all, your 100 level programming course might be a good place to start. If you'd like more guidance ask your lead(s) and they will help you out.</p> <p>If you have some experience in any programming language, you should be able to pick up most things you need by going through the tutorials and searching/LLMing things that you don't recognize.</p> <p>If you'd like to go through some very comprehensive tutorials/guides before you start any UAS specific stuff here are the good ones:</p> <ul> <li>https://docs.python.org/3/tutorial/index.html</li> <li>https://www.learncpp.com/</li> </ul>"},{"location":"Multirotor/Tutorials/First_Steps/3._Recommended_Tutorials/#linux","title":"Linux","text":"<p>The previous tutorial should (I'm hoping) give you enough context to start the ROS2 tutorials. Most commands and concepts you should be able to pickup as you go.</p> <p>If you'd like to go even further the most immediately relevant \"Linux topics\" will be sysadmin related. I don't have any recommended tutorials, but topics of note include <code>processes</code> <code>package managment</code>, <code>networking</code>, <code>tailsale</code>, <code>udev</code>, and <code>systemd</code>.</p>"},{"location":"Multirotor/Tutorials/First_Steps/3._Recommended_Tutorials/#ros2","title":"ROS2","text":"<p>The Robot Operating System (ROS) is a set of software libraries and tools for building robot applications. From drivers and state-of-the-art algorithms to powerful developer tools, ROS has the open source tools you need for your next robotics project.</p> <p>For our team ROS2 acts as the middleware the binds all of our systems together, it enables communication with the drone and is a key interface we develop against. It provides a concurrency and parallelism framework for our applications and brings a standardized pub/sub, service, and action based IPC mechanism.</p> <p>Main documentation: https://docs.ros.org/en/humble/index.html</p> <p>Recommend Tutorials to complete: https://docs.ros.org/en/humble/Tutorials.html</p> <ul> <li>All of <code>Beginner: CLI tools</code><ul> <li>Most of <code>Configuring environment</code> has been done for you if you are using the development container, but you should read it anyways to get familiar with the CLI.<ul> <li>We do not set <code>ROS_LOCALHOST_ONLY=1</code> because the container is not setup for <code>network_mode: host</code></li> </ul> </li> </ul> </li> <li>Most of <code>Beginner: Client libraries</code><ul> <li>Using colcon to build packages</li> <li>Creating a workspace</li> <li>Creating a package</li> <li>Writing a simple publisher and subscriber (C++)</li> <li>Writing a simple publisher and subscriber (Python)</li> <li>Writing a simple service and client (C++)</li> <li>Writing a simple service and client (Python)</li> <li>Creating custom msg and srv files</li> <li>Implementing custom interfaces</li> <li>Using parameters in a class (C++)</li> <li>Using parameters in a class (Python)</li> </ul> </li> </ul> <p>I recommend using using the <code>uas_ws</code> directory for your workspace as the container's <code>.bashrc</code> comes preconfigured to use this workspace.</p> <p>The concepts page is good place to learn more about the inner workings of ROS: https://docs.ros.org/en/humble/Concepts.html</p>"},{"location":"Multirotor/Tutorials/First_Steps/3._Recommended_Tutorials/#px4","title":"PX4","text":"<p>PX4 is the Professional Autopilot. Developed by world-class developers from industry and academia, and supported by an active world wide community, it powers all kinds of vehicles from racing and cargo drones through to ground vehicles and submersibles.</p> <p>PX4 is our chosen autopilot and contains the fundamental routines that allow the drone to fly.</p> <p>The drones currently use PX4 v1.16 so select that version of the docs to get the most relevant information.</p> <p>Main documentation: https://docs.px4.io/main/en/</p> <p>Read the basic concepts page to get familiar with basic drone concepts: https://docs.px4.io/main/en/getting_started/px4_basic_concepts.html</p> <p>We make heavy use of offboard control for our autonomy, specially we use ROS2 and the uXRCE-DDS interface, there are quite a few pages, but skim a few to get a feel for what we are working with: https://docs.px4.io/main/en/ros/offboard_control.html</p> <p>In the container, PX4 has been setup in <code>/build/PX4-Autopilot</code>, and the <code>MicroXRCEAgent</code> has already been installed.</p> <p>Recommended \"Tutorial\": https://docs.px4.io/main/en/ros2/offboard_control</p> <ul> <li>Follow the instructions to install</li> </ul> <p>We are specifically using the uXRCE-DDS bridge to communicate with the drone, see here to learn more about its implementation: https://docs.px4.io/main/en/middleware/uxrce_dds.html</p>"},{"location":"Multirotor/Tutorials/First_Steps/3._Recommended_Tutorials/#gazebo","title":"Gazebo","text":"<p>Gazebo brings a fresh approach to simulation with a complete toolbox of development libraries and cloud services to make simulation easy. Iterate fast on your new physical designs in realistic environments with high fidelity sensors streams. Test control strategies in safety, and take advantage of simulation in continuous integration tests.</p> <p>PX4 has already done most of the setup for us, but if you are interested in modifying the simulation or just want to learn more, feel free to read a few pages.</p> <p>Main documentation: https://gazebosim.org/docs/harmonic/tutorials/</p>"},{"location":"Multirotor/Tutorials/First_Steps/3._Recommended_Tutorials/#onboarding-project","title":"Onboarding Project","text":"<p>The best way to get learn the basics is by doing, as such I have scoped a smallish scale learning project that you can undertake (not for marks).</p> <p>To get started create a ROS package in <code>uas_ws/src</code>, use the PX4 offboard docs as reference.</p> <p>Requirements (purposefully open ended):</p> <ul> <li>Software system that enables autonomous control of a drone in simulation</li> <li>The system should:</li> <li>Allow the drone to take off</li> <li>Allow the drone to go to a location via local coordinates</li> <li>Allow the drone to go to a location via global coordinates</li> <li>Allow the drone to land</li> <li>Can be done either in Python or C++ or both or anything you want.</li> </ul> <p>Demonstrate:</p> <ul> <li>Take off</li> <li>The drone creates a square pattern in the sky (preprogrammed coordinates)</li> <li>The drone creates a square pattern in the sky (generated at runtime coordinates)</li> <li>The drone creates a shape of your choosing in the sky</li> <li>Landing</li> </ul> <p>Bonus:</p> <ul> <li>The drone will takeoff and wait for the user to select what pattern to fly in.</li> </ul> <p>These are all concepts that are used in our actual systems, by developing your own solution you will learn strong fundamentals and bring a unique perspective for the team.</p> <p>Consult this wiki and the <code>dev_env</code> README for additional reference.</p>"}]}